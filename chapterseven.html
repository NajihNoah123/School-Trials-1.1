<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 7: The Mirror Maze - SCHOOL TRIALS</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body class="bg-black text-white font-mono">
    <div class="container mx-auto px-4 py-8 min-h-screen">
        <h1 class="text-4xl font-bold mb-8 text-center glitch-text">CHAPTER 7: THE MIRROR MAZE</h1>
        
        <div class="survivor-count text-center mb-6" id="survivor-count">68 students remain</div>
        
        <div class="trial-container screen-flicker">
            <div class="trial-title">TRIAL SEVEN: THE MIRROR MAZE</div>
            
            <div class="trial-description mb-8">
                <p>You will enter a maze of glass. The reflections will confuse you. The paths will test you.</p>
                <p>Only logic, memory, and instinct will guide you out.</p>
                <p>The maze has only 40 exits. First come, first served. The rest... will remain inside.</p>
            </div>
            
            <div class="timer text-center mb-8" id="timer">25:00</div>
            
            <div id="maze-container" class="maze-container mb-8">
                <!-- Maze will be generated by JavaScript -->
                <div id="maze-player" class="maze-player"></div>
                <div id="maze-exit" class="maze-exit"></div>
                
                <!-- Overlay for reflections -->
                <div id="reflection-overlay" class="absolute inset-0 pointer-events-none opacity-50"></div>
            </div>
            
            <div class="text-center mb-6">
                <p class="text-gray-400 mb-2">Use arrow keys or WASD to move</p>
                <p class="text-gray-400">Mobile users: Use the controls below</p>
            </div>
            
            <div id="mobile-controls" class="grid grid-cols-3 gap-2 max-w-xs mx-auto mb-8">
                <div></div>
                <button id="up-btn" class="game-btn p-3 bg-gray-800 hover:bg-gray-700">‚Üë</button>
                <div></div>
                <button id="left-btn" class="game-btn p-3 bg-gray-800 hover:bg-gray-700">‚Üê</button>
                <button id="down-btn" class="game-btn p-3 bg-gray-800 hover:bg-gray-700">‚Üì</button>
                <button id="right-btn" class="game-btn p-3 bg-gray-800 hover:bg-gray-700">‚Üí</button>
            </div>
            
            <div class="text-center">
                <button id="start-trial" class="game-btn px-8 py-3 text-xl bg-red-900 hover:bg-red-700 transition-colors duration-300 rounded-sm">ENTER THE MAZE</button>
            </div>
        </div>
        
        <div class="fixed bottom-4 right-4 flex space-x-4">
            <button id="sound-toggle" class="px-3 py-1 bg-gray-800 rounded-sm">üîä</button>
            <button id="music-toggle" class="px-3 py-1 bg-gray-800 rounded-sm">‚ô™ ON</button>
        </div>
    </div>
    
    <script src="scripts.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Load game state
            loadGameState();
            gameState.survivorCount = 68; // Set for this chapter
            updateSurvivorCount();
            
            // Play trial music
            playMusic('sounds/tension_theme.mp3');
            
            // Trial elements
            const startButton = document.getElementById('start-trial');
            const mazeContainer = document.getElementById('maze-container');
            const mazePlayer = document.getElementById('maze-player');
            const mazeExit = document.getElementById('maze-exit');
            const reflectionOverlay = document.getElementById('reflection-overlay');
            
            // Mobile controls
            const upButton = document.getElementById('up-btn');
            const leftButton = document.getElementById('left-btn');
            const downButton = document.getElementById('down-btn');
            const rightButton = document.getElementById('right-btn');
            
            // Maze configuration
            const mazeWidth = 600;
            const mazeHeight = 400;
            const cellSize = 40;
            const cols = Math.floor(mazeWidth / cellSize);
            const rows = Math.floor(mazeHeight / cellSize);
            
            let maze = [];
            let playerPosition = { x: 0, y: 0 };
            let exitPosition = { x: 0, y: 0 };
            let reflections = [];
            let isGameActive = false;
            
            // Generate maze
            function generateMaze() {
                // Initialize maze grid
                maze = [];
                for (let y = 0; y < rows; y++) {
                    const row = [];
                    for (let x = 0; x < cols; x++) {
                        row.push({
                            x,
                            y,
                            walls: {
                                top: true,
                                right: true,
                                bottom: true,
                                left: true
                            },
                            visited: false,
                            isMirror: Math.random() < 0.3 // 30% chance of being a mirror
                        });
                    }
                    maze.push(row);
                }
                
                // Generate maze using recursive backtracking
                const stack = [];
                const startCell = maze[0][0];
                startCell.visited = true;
                stack.push(startCell);
                
                while (stack.length > 0) {
                    const currentCell = stack[stack.length - 1];
                    const neighbors = getUnvisitedNeighbors(currentCell);
                    
                    if (neighbors.length === 0) {
                        stack.pop();
                    } else {
                        const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                        removeWallsBetween(currentCell, randomNeighbor);
                        randomNeighbor.visited = true;
                        stack.push(randomNeighbor);
                    }
                }
                
                // Set player starting position
                playerPosition = { x: 0, y: 0 };
                
                // Set exit position (far corner)
                exitPosition = { x: cols - 1, y: rows - 1 };
                
                // Generate reflections
                generateReflections();
            }
            
            // Get unvisited neighbors
            function getUnvisitedNeighbors(cell) {
                const { x, y } = cell;
                const neighbors = [];
                
                // Top
                if (y > 0 && !maze[y - 1][x].visited) {
                    neighbors.push(maze[y - 1][x]);
                }
                
                // Right
                if (x < cols - 1 && !maze[y][x + 1].visited) {
                    neighbors.push(maze[y][x + 1]);
                }
                
                // Bottom
                if (y < rows - 1 && !maze[y + 1][x].visited) {
                    neighbors.push(maze[y + 1][x]);
                }
                
                // Left
                if (x > 0 && !maze[y][x - 1].visited) {
                    neighbors.push(maze[y][x - 1]);
                }
                
                return neighbors;
            }
            
            // Remove walls between two cells
            function removeWallsBetween(cell1, cell2) {
                const xDiff = cell2.x - cell1.x;
                const yDiff = cell2.y - cell1.y;
                
                if (xDiff === 1) {
                    // cell2 is to the right of cell1
                    cell1.walls.right = false;
                    cell2.walls.left = false;
                } else if (xDiff === -1) {
                    // cell2 is to the left of cell1
                    cell1.walls.left = false;
                    cell2.walls.right = false;
                } else if (yDiff === 1) {
                    // cell2 is below cell1
                    cell1.walls.bottom = false;
                    cell2.walls.top = false;
                } else if (yDiff === -1) {
                    // cell2 is above cell1
                    cell1.walls.top = false;
                    cell2.walls.bottom = false;
                }
            }
            
            // Generate reflections
            function generateReflections() {
                reflections = [];
                
                // Add some reflections to confuse the player
                for (let i = 0; i < 5; i++) {
                    reflections.push({
                        x: Math.floor(Math.random() * mazeWidth),
                        y: Math.floor(Math.random() * mazeHeight),
                        size: 20 + Math.floor(Math.random() * 20)
                    });
                }
            }
            
            // Render maze
            function renderMaze() {
                // Clear existing maze
                while (mazeContainer.firstChild) {
                    mazeContainer.removeChild(mazeContainer.firstChild);
                }
                
                // Add player
                mazePlayer.style.left = `${playerPosition.x * cellSize + 10}px`;
                mazePlayer.style.top = `${playerPosition.y * cellSize + 10}px`;
                mazeContainer.appendChild(mazePlayer);
                
                // Add exit
                mazeExit.style.left = `${exitPosition.x * cellSize + 5}px`;
                mazeExit.style.top = `${exitPosition.y * cellSize + 5}px`;
                mazeContainer.appendChild(mazeExit);
                
                // Add walls
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const cell = maze[y][x];
                        
                        // Add walls
                        if (cell.walls.top) {
                            const wall = document.createElement('div');
                            wall.className = 'maze-wall';
                            wall.style.left = `${x * cellSize}px`;
                            wall.style.top = `${y * cellSize}px`;
                            wall.style.width = `${cellSize}px`;
                            wall.style.height = '1px';
                            mazeContainer.appendChild(wall);
                        }
                        
                        if (cell.walls.right) {
                            const wall = document.createElement('div');
                            wall.className = 'maze-wall';
                            wall.style.left = `${(x + 1) * cellSize}px`;
                            wall.style.top = `${y * cellSize}px`;
                            wall.style.width = '1px';
                            wall.style.height = `${cellSize}px`;
                            mazeContainer.appendChild(wall);
                        }
                        
                        if (cell.walls.bottom) {
                            const wall = document.createElement('div');
                            wall.className = 'maze-wall';
                            wall.style.left = `${x * cellSize}px`;
                            wall.style.top = `${(y + 1) * cellSize}px`;
                            wall.style.width = `${cellSize}px`;
                            wall.style.height = '1px';
                            mazeContainer.appendChild(wall);
                        }
                        
                        if (cell.walls.left) {
                            const wall = document.createElement('div');
                            wall.className = 'maze-wall';
                            wall.style.left = `${x * cellSize}px`;
                            wall.style.top = `${y * cellSize}px`;
                            wall.style.width = '1px';
                            wall.style.height = `${cellSize}px`;
                            mazeContainer.appendChild(wall);
                        }
                        
                        // Add mirror effect for mirror cells
                        if (cell.isMirror) {
                            const mirror = document.createElement('div');
                            mirror.className = 'absolute bg-gray-300 bg-opacity-20';
                            mirror.style.left = `${x * cellSize + 5}px`;
                            mirror.style.top = `${y * cellSize + 5}px`;
                            mirror.style.width = `${cellSize - 10}px`;
                            mirror.style.height = `${cellSize - 10}px`;
                            mazeContainer.appendChild(mirror);
                        }
                    }
                }
                
                // Add reflections
                reflectionOverlay.innerHTML = '';
                reflections.forEach(reflection => {
                    const reflectionElement = document.createElement('div');
                    reflectionElement.className = 'absolute bg-white bg-opacity-10 rounded-full';
                    reflectionElement.style.left = `${reflection.x}px`;
                    reflectionElement.style.top = `${reflection.y}px`;
                    reflectionElement.style.width = `${reflection.size}px`;
                    reflectionElement.style.height = `${reflection.size}px`;
                    reflectionOverlay.appendChild(reflectionElement);
                });
                
                mazeContainer.appendChild(reflectionOverlay);
            }
            
            // Move player
            function movePlayer(direction) {
                if (!isGameActive) return;
                
                const currentCell = maze[playerPosition.y][playerPosition.x];
                let newX = playerPosition.x;
                let newY = playerPosition.y;
                
                switch (direction) {
                    case 'up':
                        if (!currentCell.walls.top) newY--;
                        break;
                    case 'right':
                        if (!currentCell.walls.right) newX++;
                        break;
                    case 'down':
                        if (!currentCell.walls.bottom) newY++;
                        break;
                    case 'left':
                        if (!currentCell.walls.left) newX--;
                        break;
                }
                
                // Check if move is valid
                if (newX !== playerPosition.x || newY !== playerPosition.y) {
                    playerPosition.x = newX;
                    playerPosition.y = newY;
                    
                    // Update player position
                    mazePlayer.style.left = `${playerPosition.x * cellSize + 10}px`;
                    mazePlayer.style.top = `${playerPosition.y * cellSize + 10}px`;
                    
                    playSound('sounds/click.mp3');
                    
                    // Check if player reached exit
                    if (playerPosition.x === exitPosition.x && playerPosition.y === exitPosition.y) {
                        mazeCompleted();
                    }
                } else {
                    // Hit a wall
                    playSound('sounds/failure.mp3');
                }
            }
            
            // Maze completed
            function mazeCompleted() {
                isGameActive = false;
                stopTimer();
                playSound('sounds/success.mp3');
                
                // Calculate elimination
                const eliminationRate = 0.4; // 40% elimination
                const eliminated = Math.floor(gameState.survivorCount * eliminationRate);
                const remaining = gameState.survivorCount - eliminated;
                
                trialSuccess(remaining, 'chaptereight.html');
            }
            
            // Start trial
            startButton.addEventListener('click', function() {
                playSound('sounds/click.mp3');
                startButton.classList.add('hidden');
                
                // Generate and render maze
                generateMaze();
                renderMaze();
                
                // Start timer
                startTimer(25 * 60, () => {
                    // Time's up
                    gameOver('You failed to escape the maze in time.');
                });
                
                isGameActive = true;
            });
            
            // Keyboard controls
            document.addEventListener('keydown', function(e) {
                if (!isGameActive) return;
                
                switch (e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        movePlayer('up');
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        movePlayer('right');
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        movePlayer('down');
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        movePlayer('left');
                        break;
                }
            });
            
            // Mobile controls
            upButton.addEventListener('click', () => movePlayer('up'));
            rightButton.addEventListener('click', () => movePlayer('right'));
            downButton.addEventListener('click', () => movePlayer('down'));
            leftButton.addEventListener('click', () => movePlayer('left'));
        });
    </script>
</body>
</html>
